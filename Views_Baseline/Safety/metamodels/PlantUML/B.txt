@startuml
class Abstraction  {
	name: EString
}
class Machine  {
}
class Implementation  {
}
class Sees  {
}
class Imports  {
}
class Values  {
}
class ValueExpr  {
	value: EString
}
class ConcreteVariables  {
}
class Variable  {
	name: EString
}
class ConcreteConstants  {
}
class Invariant  {
}
class InvariantExpr  {
}
class Type  {
}
enum PrimitiveTypeEnum  {
	BOOL: BOOL
	INT: INT
	NAT: NAT
	NAT1: NAT1
	STRING: STRING
}
class Initialisation  {
}
class InitialisationExpr  {
}
class Properties  {
}
class PropertyExpr  {
}
class Range  {
	lowerBound: EInt
}
class Assertions  {
}
class AssertionExpr  {
}
class Definitions  {
}
class Definition  {
	name: EString
}
class LogicalExpr  {
}
enum InequalityOp  {
	<: LESS
	<=: LESS_EQ
	>: GREATER
	>=: GREATER_EQ
}
class DefinitionCall  {
}
class IntLiteral  {
	value: EInt
}
enum BoolLiteralEnum  {
	TRUE: TRUE
	FALSE: FALSE
}
class Sets  {
}
class Set  {
}
class Operations  {
}
class Operation  {
	name: EString
}
class Body  {
}
class Expr  {
}
class Skip  {
}
class Statement  {
}
class If  {
}
class IfCond  {
}
class Condition  {
}
class Pre  {
}
class PreExpr  {
}
class Var  {
}
class Begin  {
}
class BeginBody  {
}
class Assign  {
}
class Return  {
}
class ReturnTypeExpr  {
}
class ReturnExpr  {
}
class Case  {
}
class CaseExpr  {
}
class Seq  {
}
class FinalExpr  {
}
class Call  {
}
class SimpleCall  {
}
class Arg  {
}
class LocalOperations  {
}
class PrimitiveType  {
	type: PrimitiveTypeEnum
}
class Ref  {
}
class PropertyTyped  {
}
class PropertyRange  {
}
class AndExpr  {
}
class ImplyExpr  {
}
class InequalityExpr  {
	op: InequalityOp
}
class EqualExpr  {
}
class NegExpr  {
}
class BoolTest  {
}
class TypeConstraint  {
}
class ConstantExpr  {
	constant: BoolLiteralEnum
}
class CondAnd  {
}
class CondEq  {
}
class CondLessThan  {
}
class CondMinus  {
}
class CondNeg  {
}
class BoolLiteral  {
	value: BoolLiteralEnum
	constant: BoolLiteralEnum
}
class ReturnTuple  {
}
class ReturnOr  {
}
class Neg  {
}
class ArgMinus  {
}
class StringLiteral  {
	value: EString
}
Abstraction <|-- Machine
Abstraction <|-- Implementation
LogicalExpr <|-- DefinitionCall
LogicalExpr <|-- IntLiteral
Condition <|-- IntLiteral
Arg <|-- IntLiteral
Body <|-- Skip
Expr <|-- Skip
Body <|-- If
Expr <|-- If
FinalExpr <|-- If
Body <|-- Pre
Body <|-- Var
Expr <|-- Var
FinalExpr <|-- Var
Body <|-- Begin
Expr <|-- Assign
Statement <|-- Assign
Expr <|-- Return
FinalExpr <|-- Return
Return <|-- ReturnTypeExpr
Expr <|-- Case
FinalExpr <|-- Case
Body <|-- Seq
BeginBody <|-- Seq
BeginBody <|-- FinalExpr
Expr <|-- Call
Statement <|-- Call
Type <|-- PrimitiveType
Type <|-- Ref
LogicalExpr <|-- Ref
Condition <|-- Ref
ReturnExpr <|-- Ref
Arg <|-- Ref
PropertyExpr <|-- PropertyTyped
PropertyExpr <|-- PropertyRange
LogicalExpr <|-- AndExpr
LogicalExpr <|-- ImplyExpr
LogicalExpr <|-- InequalityExpr
LogicalExpr <|-- EqualExpr
LogicalExpr <|-- NegExpr
LogicalExpr <|-- BoolTest
ReturnExpr <|-- BoolTest
LogicalExpr <|-- TypeConstraint
LogicalExpr <|-- ConstantExpr
Condition <|-- CondAnd
Condition <|-- CondEq
Condition <|-- CondLessThan
Condition <|-- CondMinus
Condition <|-- CondNeg
Condition <|-- BoolLiteral
ReturnExpr <|-- BoolLiteral
Arg <|-- BoolLiteral
Return <|-- ReturnTuple
ReturnTypeExpr <|-- ReturnOr
ReturnExpr <|-- Neg
Arg <|-- ArgMinus
Arg <|-- StringLiteral
Abstraction *--> "sees" Sees
Abstraction *--> "concreteConstants" ConcreteConstants
Abstraction *--> "definitions" Definitions
Abstraction *--> "properties" Properties
Abstraction *--> "operations" Operations
Machine *--> "concreteVariables" ConcreteVariables
Machine *--> "invariant" Invariant
Machine *--> "initialisation" Initialisation
Machine *--> "assertions" Assertions
Machine *--> "sets" Sets
Implementation --> "refine" Machine
Implementation *--> "imports" Imports
Implementation *--> "values" Values
Implementation *--> "localOperations" LocalOperations
Sees --> "seens *" Abstraction
Imports --> "imports *" Abstraction
Values *--> "exprs *" ValueExpr
ValueExpr --> "constant" Variable
ConcreteVariables *--> "variables *" Variable
ConcreteConstants *--> "constants *" Variable
Invariant *--> "exprs *" InvariantExpr
InvariantExpr --> "variable" Variable
InvariantExpr *--> "type" Type
Initialisation *--> "exprs *" InitialisationExpr
InitialisationExpr --> "variable" Variable
InitialisationExpr *--> "type" Type
Properties *--> "exprs *" PropertyExpr
Properties *--> "expr *" PropertyExpr
PropertyExpr --> "constant" Variable
Range --> "upperBound" Variable
Assertions *--> "exprs *" AssertionExpr
AssertionExpr --> "constant" Variable
AssertionExpr *--> "type" Type
Definitions *--> "exprs *" Definition
Definition *--> "args *" Variable
Definition *--> "expr" LogicalExpr
DefinitionCall --> "def" Definition
DefinitionCall *--> "args *" Arg
Sets *--> "exprs *" Set
Set *--> "name" Variable
Set *--> "elems *" Variable
Operations *--> "operations *" Operation
Operation *--> "outputs *" Variable
Operation *--> "args *" Variable
Operation *--> "body" Body
If *--> "exprs *" IfCond
If *--> "else" Expr
IfCond *--> "condition" Condition
IfCond *--> "then" Expr
Pre *--> "exprs *" PreExpr
Pre *--> "expr" Expr
PreExpr --> "var" Variable
PreExpr *--> "type" Type
Var *--> "vars *" Variable
Var *--> "in" Seq
Begin *--> "expr" BeginBody
Assign --> "var" Variable
Assign *--> "value" ReturnExpr
ReturnTypeExpr --> "var" Variable
ReturnTypeExpr *--> "type" Type
Case --> "var" Variable
Case *--> "cases *" CaseExpr
CaseExpr --> "test" Variable
CaseExpr *--> "expr" Expr
Seq *--> "exprs *" EObject
Call --> "rets *" Variable
Call --> "op" Operation
Call *--> "args *" Arg
SimpleCall --> "op" Operation
SimpleCall *--> "args *" Arg
LocalOperations *--> "operations *" Operation
Ref --> "type" Variable
Ref --> "var" Variable
PropertyTyped *--> "type" Type
PropertyRange *--> "range" Range
AndExpr *--> "exprs *" LogicalExpr
ImplyExpr *--> "left" LogicalExpr
ImplyExpr *--> "right" LogicalExpr
InequalityExpr *--> "left" LogicalExpr
InequalityExpr *--> "right" LogicalExpr
EqualExpr *--> "left" LogicalExpr
EqualExpr *--> "right" LogicalExpr
NegExpr *--> "expr" LogicalExpr
BoolTest *--> "expr" LogicalExpr
TypeConstraint --> "var" Variable
TypeConstraint *--> "type" Type
CondAnd *--> "exprs *" Condition
CondEq *--> "left" Condition
CondEq *--> "right" Condition
CondLessThan *--> "left" Condition
CondLessThan *--> "right" Condition
CondMinus *--> "left" Condition
CondMinus *--> "right" Condition
CondNeg *--> "expr" Condition
ReturnTuple --> "vars *" Variable
ReturnTuple *--> "value" LogicalExpr
ReturnOr *--> "exprs *" ReturnTypeExpr
Neg *--> "expr" ReturnExpr
ArgMinus *--> "left" Arg
ArgMinus *--> "right" Arg
@enduml