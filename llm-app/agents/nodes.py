import functools
from langchain_core.messages import FunctionMessage, HumanMessage
from agents.utils import create_agent

class Nodes:

    def __init__(self, llm, tools):
        self.llm = llm
        self.tools = tools

    @staticmethod
    def agent_node(state, agent, name):
        """
        Helper function to create a node for a given agent.

        Parameters
        ----------
        state : _type_
            The current state of the system.
        agent : _type_
            The agent to be used for performing the action.
        name : _type_
            The name of the agent.

        Returns
        -------
        dict
            A dictionary containing the following keys:
            - 'messages': A list of messages generated by the agent.
            - 'sender': The name of the agent.

        Notes
        -----
        This function invokes the agent on the given state and converts the agent output into a format that is suitable to append to the global state. If the agent output is an instance of `FunctionMessage`, it is left unchanged. Otherwise, it is converted into a `HumanMessage` object with the given name.

        Example
        -------
        >>> state = ...
        >>> agent = ...
        >>> name = ...
        >>> result = agent_node(state, agent, name)
        """
        result = agent.invoke(state)
        if isinstance(result, FunctionMessage):
            pass
        else:
            result = HumanMessage(**result.dict(exclude={"type", "name"}), name=name)
        return {
            "messages": [result],
            # track the sender so we know who to pass to next.
            "sender": name,
        }
    
    def join_rules_node(self):
        """
        Returns a partial function that represents the join_rules_node agent.

        Returns
        -------
        functools.partial
            A partial function that represents the join_rules_node agent.
        """
        get_join_rules_agent = create_agent(
            self.llm, 
            [self.tools[0], self.tools[1]], 
            system_message="Your task is to  analyze the two provided metamodels and find out which elements can be combined in the final View, according to the given task. \
                            In a View, the elements are combined in pairs to create a new virtual element, always according to the task.\
                            Your answer should be a list of elements.\
                            Each element of the list is a dictionary containing the name of this virtual relation and a tuple with the combined elements in the following format:\
                                    {{Relation_name: (Metamodel_Identifier.Class_name, Metamodel_Identifier.Class_name)}}\
                            Only use class names that actually exist in the metamodels; \
                                don't try to invent new class names. \
                                The relation's name should combine these class names, always in camelCase."
        )
        return functools.partial(Nodes.agent_node, agent=get_join_rules_agent, name="GetJoinRules")
    
    def filter_generator_node(self):
        """
        Returns a partial function that represents the filter_generator_node agent.

        Returns
        -------
        functools.partial
            A partial function that represents the filter_generator_node agent.
        """
        filter_generator_agent = create_agent(
            self.llm,
            [self.tools[0], self.tools[1]],
            system_message="You should provide which elements should be selected to be present in the final View.\
                        Your answer should be a list of elements.\
                        Each element is in the following format: Metamodel_Identifier.Class_name.\
                        Only use class and attribute names that actually exist in the metamodels; don't try to invent new names.\
                        Note that frequently, the metamodels can represent the same domain, so it's possible to get some overlap between them.\
                        This should be taken into account to avoid repeating information."
        )
        return functools.partial(Nodes.agent_node, agent=filter_generator_agent, name="FilterGenerator")